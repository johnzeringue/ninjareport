\chapter{Analyse du déroulement du stage}
Les retours de ce stage pour moi peuvent être classé en trois catégories : Technique, Culture Générale et Organisationel.

\section{Technique}
Le retour le plus évident de ce stage au niveau technique est l'experience acquise sur la librairie \textit{JavaFX}. Je ne la connaissais pas en arrivant à Charleston, et j'ai mis un peu de temps à assimiler les conceptes qui n'était pas dans \textit{Swing}, sa principale source d'inspiration. Ces améliorations et trouvailles, comme les \textit{Property}, le système de hierarchie des noeuds ou encore le FXML valent vraiment le coup d'être apprisent et améliorent considérablement la vie du developpeur. J'ai quelques reproches, rien de très grave, comme les bugs dues à la jeunesse de la librairie, la documentation parfois imprecise et pas des plus claires et la librairie de graphique assez limité\footnote{Des modifications peu orthodoxes nous ont éte necessaire pour permettre à l'utilisateur de se déplacer dans le schema}, mais dans l'ensemble c'est une excelente libraire que je re-utiliserai et que j'explorerai plus en détails.

Nous utilisons \textit{JavaFX 8}, qui est compatible uniquement avec \textit{Java 8}, la dernière mouture du langage. J'ai pu découvrir les nouveauté de cette nouvelle version, et plus particulièrement les fonctions lambdas. Une fonction lambda est une fonction anonyme, passé à une autre fonction. Imaginons une fonction qui trie des objets en fonction d'une regle particulière qui indique si l'objet est plus grand. Cette règle implémenté dans un objet comparateur est passé en paramètre de la fonction. Il faut donc créer cet objet comparateur à chaque fois que l'on appelle la fonction. La syntaxe pour faire ceci dans jusqu'a Java 7 était très lourde. On voyait plus que l'on créait un objet qu'une regle. Dans Java 8, on voit maintenant que l'on créé une règle. C'est très agréable!

Ce n'est ce pendant pas le concept le plus naturel dans le langage \textit{Java}. Java est basé sur le paradigme de Programation Orientée Objet. Les fonctions lambdas ont été créé pour le paradigme de Programation Fonctionnelle. Il y a des langages basés uniquement sur le principes de Programation Fonctionelle que j'ai découvers pendant ce stage, comme \textit{Haskell}. Approfondir ses connaissances dans ce paradigme est assez compliqué puisqu'il faut changer sa façon de penser du tout au tout, je n'ai donc pas eut vraiment le temps de me pencher dessus. Mais ce manque de temps n'est que temporaire.

J'ai joué avec le \textit{SVG}, je comprends un peu mieux comment ce format marche. J'ai aussi appris à utiliser Maven, un logiciel qui automatise la compilation de notre code. Souvent quand des entreprises compilent des logiciels, elles produisent plusieurs versions : debuggage, production, production pour un certain client ... Avant cela, elles testent le code qu'elle compile. Maven permet d'automatiser ces tests compilations. Il gêre aussi l'integration des librairies que l'on utilise directement. Ce n'est desormais plus au developpeur de réunir toutes les librairie dépendantes avant de compiler. Très pratique. 

Un outil qui m'a approrté des retours à la fois du côté technique et du côté organisationel : \textit{Git}, un outil de collaboratio  basé sur quelques principes simples. Cela n'empchêche pas ses possibilités d'être tellement étendues que cela le rend fascinant.J'avais déja quelques experiences avec \textit{Git} mais l'utiliser au quotidien m'a permis de vraiment me rendre compte de sa puissance. Un peu plus en particulier, j'ai appris à utiliser efficacement les branches, la difference entre pull et fetch, et différentes manières de communiquer et collaborer entre dépot.

\textit{GitHub} est un réseau social apportant ses fonctionnalité à internet et offrant d'autres services autour de Git. J'ai appris à communiquer et à collaborer sur ce site web. Je sais maintenant retrouver les différentes fonctionnalité de Git directement en ligne, je sais aussi utiliser leur \textit{Issues Tracker} et sais comment faire une pull request. Je fais maintenant énormement de choses avec \textit{Git} et \textit{Github}. Ce rapport de stage est par exemple entierement gêré avec \textit{Git} et disponible sur mon compte \textit{GitHub}.
Voyons comment Git a modelé notre façon de travailler en équipe.

%%Mentionner GitHub Pages (parce que serieux, quoi de mieux ?)

\section{L'organisation}

\subsection{L'organisation de l'équipe}
L'integralité de notre travail est organisé avec \textit{Gitub}. Notre code source y est dans un dépot, et c'est grâce là que nous fusionnons nos différents travaux. Nos listes de tâches évolue dynaniquement sur l'\textit{issue tracker}. Une \textit{issue} est crée par fonctionnalité à implémenter ou bug à résoudre pour nous ou nos utilisateurs. On en discute entre nous ou avec les utilisateurs. Nous nous les assignons ensuite, et nous les assignons aussi à une version, version qui a une date de sortie. Une issue est ouverte quand elle requiert du travail. Elles sont fermées automatiquement quand un commit la résoud. C'est sur ce tracker que nous voyons l'avancée du travail, que nous prévoyons le futur du developpement et que l'on communique avec nos utilisateurs.

J'ai aussi experimenté vers la fin de ce stage le développement à plusieurs vitesse. Le projet va bientôt commencer le developpement d'une grande librairie ce qui va sans aucun doute prendre plusieurs mois. Pendant ce temps, la réponse aux besoin urgents des utilisateurs, tels que correction de bugs et autres fonctionalités rapide à coder ne va pas s'arrêter. Nous cherchons donc un moyen d'organiser l'équipe qu'elle reste efficace sur et entre ces deux front. Il y a plusieurs façon de faire ceci et elles influent sur deux facteurs : La répartition du travail dans la journée, dans la semaine et entre les hommes. La solution que nous experimentons en ce moment est une semaine de developpement court et une semaine de recherche pour la librairie. Cela pose cenpendant des problème, notement le fait de laisser des utilisateurs sans réponse.

Sur ce point j'ai fais une autre découverte que j'ai appris à gêrer (notemment grâce à un fantastique article trouvé sur Reddit)%AJOUTER UNE REFERENCE À L'ARTICLE
: Un projet ne se fait pas à vitesse constante. Il y a des periodes, periodes de rush, où on est plongé dans le developpement d'une fonctions. C'est très agréable à court terme, on apprends beaucoup et on produit beaucoup. Mais on ne peut pas, et on ne doit surtout pas rester dans ce mode trop longtemps, d'une parce que le code produit n'est pas très glorieux, et de deux parce que l'équipe risque de s'essouffler et de produire de moins en moins, et surtout de moins en moins bien. Un autre mode est ce que l'on appelle le mode marathon. L'équipe produit, mais passe aussi du temps à côté à se relaxer, à apprendre, ou à refléchir. Et puis il y a les bien aimés jours lents, ou il ne se passe que peu de choses, et la majorité du temps est passé sur Youtube ou South Park Studio. Ah... le vendredi!

Documenter et écrire des testes sur un projet n'est pas notre fort. J'ai appris pendant ce projet que malgré toute la bonne volonté que l'on peut mettre dans ces tâches au départ, on se retrouve bien souvent le nez dans le developpement de fonctions compliqués et on oublie ces apports considérables au long terme. Il s'agit vraiment de prendre l'habitude de les écrires et d'accepter que si le developpement d'une fonction est forcement ralongée, c'est pour le bien des programmes, des utilisateurs et de l'équipe. J'ai encore beaucoup de progrès à faire dans ce domaine.

\subsection{Ma façon de concevoir un programme}

\begin{center}Le principe KISS : Keep it simple, stupid !\end{center}

Si je ne retenais qu'une seule chose de stage\footnote{Ce qui serait diqblement stupide}, ce serait que ma façon de concevoir un programme à énormement changé. Je suis arrivé aux États-Unis et ait produit au départ des fonctions comme je l'ai toujours fais. : elles répondent à un maximum de cas d'utilisations et sont très complexe. Le petit problème que j'ai appris à éviter est qu'elles répondent à des problèmes que l'équipe et le programme n'ont pas encore, et n'auront peut-être jamais. Et surtout, elles rajoutent trop de complexité au code. J'ai du bien souvent simplifier ma façon de penser pour que le code ne devienne pas une jungle.

J'ai donc cessé de produire des codes à interfaces qui produisait trop pour le futur, et ait commencé à me demander \emph{pourquoi je concevais mon code comme ça}, \emph{à qui cela allait profiter}, et : \emph{textbf{``N'y a t-il pas un moyen de le faire plus simplement ??''}}.

\begin{quote}
``Perfect is the ennemy of good'' - Jim Bowring
\end{quote}

Voilà un autre principe que j'ai au premier abord détesté puis que j'ai appris à aimé tout au long de ces 13 semaines. Produire du code parfait est dur, très dur. Cela demande beaucoup de compétences, de la concentration et de la plannification. Et surtout, cela énormément de temps. La recherche de la perfection fait dépasser les deadlines, pousse à faire et à refaire et à refaire. Les developpeurs se fatiguent et les clients ne sont pas contents du retard. Foncer et ne pas se pencher sur les détails à ceci de très, très positif : on finit et on publie la fonction. C'est un soulagement pour les développeurs, les clients sont centents. Par contre, cela apporte de la dette technique\footnote{Terme recemment inventé qui désigne le degré de mauvais code dans le projet}. Comme toute dette, il faut l'emprunter intelligement, en pensant à la façon dont on va la rembourser, pour éviter d'avoir un code trop gangrainé.
