\chapter{Analyse du déroulement du stage}
Les retours de ce stage pour moi peuvent être classés en trois catégories : Technique, Culture Générale et Organisation.

\section{Technique}
Le retour le plus évident de ce stage au niveau technique est l'experience acquise sur la librairie \textit{JavaFX}. Je ne la connaissais pas en arrivant à Charleston, et j'ai mis un peu de temps à assimiler les conceptes qui n'était pas dans \textit{Swing}, sa principale source d'inspiration. Ces améliorations et trouvailles, comme les \textit{Property}, le système de hierarchie des noeuds ou encore le FXML valent vraiment le coup d'être apprisent et améliorent considérablement la vie du developpeur. J'ai quelques reproches, rien de très grave, comme les bugs dûs à la jeunesse de la librairie, la documentation parfois imprécise et peu claire et la librairie de graphique assez limité\footnote{Des modifications peu orthodoxes nous ont éte necessaire pour permettre à l'utilisateur de se déplacer dans le schema}, mais dans l'ensemble c'est une excelente libraire que je re-utiliserai et que j'explorerai plus en détails.

Nous utilisons \textit{JavaFX 8}, qui est compatible uniquement avec \textit{Java 8}, la dernière mouture du langage. J'ai pu découvrir les nouveauté de cette nouvelle version, et plus particulièrement les fonctions lambdas. Une fonction lambda est une fonction anonyme, passé à une autre fonction. Imaginons une fonction qui trie des objets en fonction d'une regle particulière qui indique si l'objet est plus grand. Cette règle implémenté dans un objet comparateur est passé en paramètre de la fonction. Il faut donc créer cet objet comparateur à chaque fois que l'on appelle la fonction. La syntaxe pour faire ceci dans jusqu'a Java 7 était très lourde. La création de l'objet était plus évidente que la règle. Dans Java 8, la creation de la règle est plus évidente.

Ce n'est ce pendant pas le concept le plus naturel dans le langage \textit{Java}. Java est basé sur le paradigme de Programation Orientée Objet. Les fonctions lambdas ont été créé pour le paradigme de Programation Fonctionnelle. Il y a des langages basés uniquement sur le principes de Programation Fonctionelle que j'ai découvert pendant ce stage, comme \textit{Haskell}. Approfondir ses connaissances dans ce paradigme est assez compliqué puisqu'il faut changer sa façon de penser du tout au tout, je n'ai donc pas eu vraiment le temps de me pencher dessus. Mais ce manque de temps n'est que temporaire.

J'ai joué avec le \textit{SVG}, je comprends un peu mieux comment ce format marche. J'ai aussi appris à utiliser \textit{Maven}, un logiciel qui automatise la compilation de notre code. Souvent quand des entreprises compilent des logiciels, elles produisent plusieurs versions : ``debuggage'', ``production'', ``production'' ciblé pour un certain client ... Avant cela, elles testent le code. \textit{Maven} permet d'automatiser ce processus. Il gêre aussi l'integration des librairies que l'on utilise. Ce n'est desormais plus au developpeur de réunir toutes les librairie dépendantes avant de compiler, il lui suffit de les noter dans un fichier XML.

Un outil qui m'a approrté des retours à la fois du côté technique et du côté organisationel : \textit{Git}, un outil de collaboration basé sur quelques principes simples. Cela n'empchêche pas ses possibilités d'être tellement étendues que cela le rend fascinant. J'avais déja quelques experiences avec \textit{Git} mais l'utiliser au quotidien m'a permis de vraiment me rendre compte de sa puissance. J'ai appris à utiliser efficacement les branches, la difference entre pull et fetch, et différentes manières de communiquer et collaborer entre dépot.

\textit{GitHub} est un réseau social organisé entre dépot Git. Il permet à 3.5 millions d'utilisateurs de collaborer sur 10 millions de projets. J'ai appris à communiquer et à collaborer sur ce site web. Je sais maintenant retrouver les différentes fonctionnalité de Git directement en ligne, je sais aussi utiliser leur \textit{Issues Tracker} et sais comment faire une pull request. Je fais maintenant énormement de choses avec \textit{Git} et \textit{Github}. Ce rapport de stage est par exemple entierement gêré avec \textit{Git} et disponible sur mon compte \textit{GitHub}.
Voyons comment Git a modelé notre façon de travailler en équipe.

%%Mentionner GitHub Pages (parce que serieux, quoi de mieux ?)

\section{L'organisation}

\subsection{L'organisation de l'équipe}
L'integralité de notre travail est organisé avec \textit{Github}. Notre code source y est, et c'est là que nous fusionnons nos différents travaux. Nos listes de tâches évolue dynamiquement sur l'\textit{issue tracker}. Il y a une \textit{issue} par fonctionnalité à implémenter ou bug à résoudre. Elles sont crée par nous ou nos utilisateurs et débatue sur place. Nous nous les assignons, et nous les assignons aussi à une version, version qui a une date de sortie. Une issue est ouverte quand elle requiert du travail. Elles sont fermées automatiquement quand un commit la résout. C'est sur ce tracker que nous voyons l'avancée du travail, que nous prévoyons le futur du developpement et que l'on communique avec nos utilisateurs.

J'ai aussi experimenté vers la fin de ce stage le développement à plusieurs vitesses. Le projet va bientôt commencer le developpement d'une grande librairie. Une tache qui va sans aucun doute durer plusieurs mois. La réponse aux besoins urgents des utilisateurs, tels que corrections de bugs et autres fonctionalités rapides à coder ne doit cependant pas s'arrêter. Nous cherchons donc un moyen d'organiser l'équipe afin qu'elle reste efficace sur et entre ces deux fronts. Les différentes solutions à ce problème influent sur deux facteurs : La répartition du travail dans la journée ou dans la semaine et entre les hommes. La solution que nous experimentons en ce moment est l'alternance entre une semaine de developpement court et une semaine de recherche pour la librairie. Cela pose cependant des problèmes, notement le fait de laisser des utilisateurs sans réponses pendant une longue semaine.

Sur ce point j'ai fais une autre découverte que j'ai appris à gêrer (notemment grâce à un fantastique article trouvé sur Reddit) %AJOUTER UNE REFERENCE À L'ARTICLE
: Un projet ne se fait pas à vitesse constante. Il y a des different type de périodes. Une periodes de rush, où on est plongé dans le developpement d'une fonctions est très agréable à court terme car on apprends et on produit beaucoup. Mais cette periode ne peut, et ne doit surtout pas, être trop longue, parce que le code produit n'est pas très glorieux et parce que l'équipe risque de s'essouffler et de produire de moins en moins, et surtout de moins en moins bien. Un autre mode est appelé le mode marathon. L'équipe produit, mais passe aussi du temps à côté à se relaxer, à apprendre, ou à refléchir. Et puis il y a les bien aimés jours lents, ou il ne se passe que peu de choses, et la majorité du temps est passé sur Youtube ou South Park Studio. Ah... le vendredi!

Documenter et écrire des testes sur un projet n'est pas notre fort. J'ai appris pendant ce projet que malgré toute la bonne volonté que mise dans ces tâches au départ, je me retrouve bien souvent le nez dans le developpement de fonctions compliqués et oublie ces apports considérables au long terme. Il s'agit vraiment de prendre l'habitude de les produire et d'accepter que si le developpement d'une fonction est forcement ralongée, c'est pour le bien des programmes, des utilisateurs et de l'équipe. J'ai encore beaucoup de progrès à faire dans ce domaine.

\subsection{L'organisations de mes programmes}

\begin{quote}Le principe KISS : Keep it simple, stupid !\end{quote}

Si je ne retenais qu'une seule chose de stage\footnote{Ce qui serait diablement stupide}, ce serait que ma façon de concevoir un programme à énormement changé. Je suis arrivé aux États-Unis et ait produit au départ des fonctions comme je l'ai toujours conçues : répondant à un maximum de cas d'utilisations et très complexe. Le petit problème que j'ai appris à éviter est qu'elles répondent à des problèmes que l'équipe et le programme n'ont pas encore, et n'auront peut-être jamais. Et surtout, elles rajoutent trop de complexité au code. J'ai dû bien souvent simplifier ma façon de penser pour que le code du projet entier ne devienne pas une jungle.

J'ai donc cessé de produire des codes à interfaces qui produisait trop pour le futur, et ait commencé à me demander \emph{pourquoi je concevais mon code comme ça}, \emph{à qui cela allait profiter}, et : \emph{\textbf{``N'y a t-il pas un moyen de le faire plus simplement ??''}}.

\begin{quote}
``Perfect is the ennemy of good'' - Jim Bowring
\end{quote}

Voilà un autre principe que j'ai au premier abord détesté puis que j'ai appris à aimé tout au long de ces 13 semaines. Produire du code parfait est dur, très dur. Cela demande beaucoup de compétences, de la concentration et de la planification. Et surtout, cela prends énormément de temps. La recherche de la perfection fait dépasser les deadlines, pousse à faire et à refaire et à refaire. Les developpeurs se fatiguent et les clients ne sont pas content du retard. Foncer et ne pas se pencher sur les détails à ceci de très, très positif : on finit et on publie la fonction. C'est un soulagement pour les développeurs, les clients sont contents. Par contre, cela apporte de la dette technique\footnote{Terme recemment inventé qui désigne le degré de mauvais code dans le projet}. Comme toute dette, il faut l'emprunter intelligement, en pensant à la façon dont on va la rembourser, pour éviter d'avoir un code trop gangrainé.

\section{Culture Générale}
\subsection{Geochronologie}
J'ai un peu appris ce qu'étais la géochronologie. Je sais mainenant qu'il n'y a pas que le carbon 14 qui permet de dater des objets terrestres, et que le travail des géochronologistes est important pour garder notre espèce en vie. Ils étudient en effets des différentes catastrophes naturelles ayant causés la mort d'espèces entieres, comme les dinosaures. Ils cherchent la durées de ces catastrophes, leur causes et comment nous pouvons nous en proteger. Il a recemment été prouvé qu'une eruption volcanique ayant durée seulement une dizaine de milliers d'année avait presque eradiqué la vie sur notre planète.
Je sais aussi maintenant que l'uranium se transforme en plomb avec le temps, ce qu'est une capsule et ce qu'est le zircon.

Dans le champs des sciences, j'ai aussi amélioré et mis à profit mes connaissances en statistiques. Je comprends mieux maintenant ce que sont les marges d'erreurs et comment les utiliser.

\subsection{Marché du travail français et américain}
Après avoir longuement discuté du sujet avec différentes personnes, je me rends comptes des différences entre ce que les entreprises américaines et françaises requierent à l'embauche et entre leur méthodes de travail. 

En france, le diplôme est très important, celui d'ingénieur ouvre les portes de grandes entreprises et de postes interessant. Aux États-Unis, si obtenir son bachelor est important, c'est ce que l'on fait à côté qui montre la différence. Les étudiants sont encouragés à publier, contribuer à des projets open source, à faire des stages d'\emph{informatique} l'été ou encore à integrer des laboratoires de recherches. Le cursus seul ne donne rien de bien interessant.

En France, j'ai aussi l'impression que le système est très hierarchique. Les employés ont un patron, des ordres, montent en grade avant de pouvoir prendre des décisions. Aux États-Unis au contraire, l'innovation est encouragée. Un jeune employé peut aller voir son boss et lui proposer un projet. Si celui-ci est bénéfique pour l'entreprise, il aura la responsabilité de le mettre en place. 

Deux façon de penser très differentes.

\subsection{Graphiques}
J'ai du vers la fin de mon stage résumer un livre en entier sur les graphiques. C'était une experience interessante et j'ai appris énormement sur les qualités qui font une bonne visualisations de données en générales, les différentes possibilités offertes par les différents type de graphique, à quel point un graphique peu aussi être tompeur sur les données qu'il oense représenter, et à quel point cela peut être un excelent moyen de communication. Je sais aussi maintenant grâce à cette experience ingurgiter beaucoup d'informations en très peu de temps, un atout très profitable.
